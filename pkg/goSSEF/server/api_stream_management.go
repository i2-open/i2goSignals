/*
 * Stream Management API for OpenID Shared Security Events
 *
 * [OpenID Spec](https://openid.net/specs/openid-sse-framework-1_0.html#management)  HTTP API to be implemented by Event Transmitters. This API can be used by Event Receivers to query and update the Event Stream configuration and status, to add and remove subjects, and to trigger verification.
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package server

import (
	"encoding/json"
	"i2goSignals/internal/eventRouter"
	"i2goSignals/internal/model"
	"net/http"

	"github.com/gorilla/mux"
)

func (sa *SignalsApplication) AddSubject(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusNotImplemented)
}

func (sa *SignalsApplication) GetStatus(w http.ResponseWriter, r *http.Request) {
	sid, status := ValidateAuthorization(r, sa.Provider.GetAuthValidatorPubKey())

	if status != http.StatusOK {
		w.WriteHeader(status)
		return
	}
	if sid == "" {
		// The authorization token had no stream identifier in it
		w.WriteHeader(http.StatusForbidden)
		return
	}

	// vars := mux.Vars(r)
	// subject := vars["subject"]

	streamStatus, err := sa.Provider.GetStatus(sid)
	if err != nil {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	resp, _ := json.Marshal(*streamStatus)
	_, _ = w.Write(resp)
}

func (sa *SignalsApplication) RemoveSubject(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusNotImplemented)
}

func (sa *SignalsApplication) StreamDelete(w http.ResponseWriter, r *http.Request) {
	sid, status := ValidateAuthorization(r, sa.Provider.GetAuthValidatorPubKey())
	serverLog.Printf("Stream %s DELETE requested.", sid)
	if status != http.StatusOK {
		w.WriteHeader(status)
		return
	}
	if sid == "" {
		// The authorization token had no stream identifier in it
		w.WriteHeader(http.StatusForbidden)
		return
	}

	state, err := sa.Provider.GetStreamState(sid)
	if err != nil {
		w.WriteHeader(http.StatusNotFound)
		return
	}
	state.Status = model.StreamStateInactive
	sa.EventRouter.UpdateStreamState(state)

	// Stop all the inbound traffic if Polling
	sa.ClosePollReceiver(sid)

	// Stop any outbound activity
	sa.EventRouter.RemoveStream(sid)

	err = sa.Provider.DeleteStream(sid)
	if err != nil {
		if err.Error() == "not found" {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		w.WriteHeader(http.StatusInternalServerError)
		_, _ = w.Write([]byte(err.Error()))
	}
	// sa.EventRouter.RemoveStream(sid)
	w.WriteHeader(http.StatusOK)
	serverLog.Printf("Stream %s inactivated and deleted.", sid)
}

func (sa *SignalsApplication) StreamGet(w http.ResponseWriter, r *http.Request) {
	sid, status := ValidateAuthorization(r, sa.Provider.GetAuthValidatorPubKey())

	if status != http.StatusOK {
		w.WriteHeader(status)
		return
	}
	if sid == "" {
		// The authorization token had no stream identifier in it
		w.WriteHeader(http.StatusForbidden)
		return
	}

	config, err := sa.Provider.GetStream(sid)
	if err != nil {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	serverLog.Printf("Stream GET %s", sid)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	resp, _ := json.Marshal(config)
	_, _ = w.Write(resp)
}

func (sa *SignalsApplication) StreamPost(w http.ResponseWriter, r *http.Request) {
	sid, status := ValidateAuthorization(r, sa.Provider.GetAuthValidatorPubKey())

	if status != http.StatusOK {
		w.WriteHeader(status)
		return
	}
	if sid == "" {
		// The authorization token had no stream identifier in it
		w.WriteHeader(http.StatusForbidden)
		return
	}

	var jsonRequest model.StreamConfiguration
	err := json.NewDecoder(r.Body).Decode(&jsonRequest)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	resetJti := jsonRequest.ResetJti
	resetDate := jsonRequest.ResetDate

	jsonRequest.ResetDate = nil
	jsonRequest.ResetJti = ""

	configResp, err := sa.Provider.UpdateStream(sid, jsonRequest)
	if err != nil {
		if err.Error() == "not found" {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		_, _ = w.Write([]byte(err.Error()))
		w.WriteHeader(http.StatusInternalServerError)
	}

	streamState, err := sa.Provider.GetStreamState(sid)
	if resetDate != nil || resetJti != "" {
		// reset the stream to a particular date
		err := sa.Provider.ResetEventStream(sid, resetJti, resetDate, func(eventRecord *model.EventRecord) bool {
			// Because reset goes through all events, this function confirms the stream should get the event
			return eventRouter.StreamEventMatch(streamState, eventRecord)
		})
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
	}

	if jsonRequest.ResetJti != "" {
		// reset the stream to a particular jti (assuming sortable)
	}

	// Update the event router
	state, _ := sa.Provider.GetStreamState(sid)
	sa.EventRouter.UpdateStreamState(state)
	sa.HandleClientPollReceiver(state)

	serverLog.Printf("Stream %s UPDATED", sid)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	respBytes, _ := json.MarshalIndent(configResp, "", "  ")
	_, _ = w.Write(respBytes)
	// w.WriteHeader(http.StatusOK)
}

func (sa *SignalsApplication) UpdateStatus(w http.ResponseWriter, r *http.Request) {
	sid, status := ValidateAuthorization(r, sa.Provider.GetAuthValidatorPubKey())

	if status != http.StatusOK {
		w.WriteHeader(status)
		return
	}
	if sid == "" {
		// The authorization token had no stream identifier in it
		w.WriteHeader(http.StatusForbidden)
		return
	}

	var jsonRequest model.UpdateStreamStatus
	err := json.NewDecoder(r.Body).Decode(&jsonRequest)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	modified := false
	streamState, err := sa.Provider.GetStreamState(sid)
	if jsonRequest.Status != "" {
		if streamState.Status != jsonRequest.Status {
			if jsonRequest.Status == model.StreamStatePause || jsonRequest.Status == model.StreamStateInactive || jsonRequest.Status == model.StreamStateActive {
				sa.Provider.UpdateStreamStatus(sid, jsonRequest.Status, jsonRequest.Reason)
				modified = true
			}

		}
	}

	if modified {
		sa.EventRouter.UpdateStreamState(streamState)
		sa.HandleClientPollReceiver(streamState)
	}

	statusResp := model.StreamStatus{
		Status: streamState.Status,
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	respBytes, _ := json.MarshalIndent(statusResp, "", "  ")
	_, _ = w.Write(respBytes)

}

func (sa *SignalsApplication) VerificationRequest(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusNotImplemented)
}

func (sa *SignalsApplication) WellKnownSseConfigurationGet(w http.ResponseWriter, _ *http.Request) {
	serverLog.Println("GET WellKnownSseConfiguration")
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	jwksUri, _ := sa.BaseUrl.Parse("/jwks.json")
	configUri, _ := sa.BaseUrl.Parse("/stream")
	statusUri, _ := sa.BaseUrl.Parse("/status")
	addSubUri, _ := sa.BaseUrl.Parse("/add-subject")
	remSubUri, _ := sa.BaseUrl.Parse("/remove-subject")
	verifyUri, _ := sa.BaseUrl.Parse("/verification")

	config := model.TransmitterConfiguration{
		Issuer:  sa.DefIssuer,
		JwksUri: jwksUri.String(),
		DeliveryMethodsSupported: []string{
			model.DeliveryPoll,
			model.DeliveryPush,
		},
		ConfigurationEndpoint:  configUri.String(),
		StatusEndpoint:         statusUri.String(),
		AddSubjectEndpoint:     addSubUri.String(),
		RemoveSubjectEndpoint:  remSubUri.String(),
		VerificationEndpoint:   verifyUri.String(),
		CriticalSubjectMembers: nil,
	}
	resp, _ := json.Marshal(config)
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write(resp)

}

func (sa *SignalsApplication) WellKnownSseConfigurationIssuerGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	vars := mux.Vars(r)
	issuer := vars["issuer"]
	serverLog.Printf("GET WellKnownSseConfigurationIssuer/%s", issuer)

	jwksUri, _ := sa.BaseUrl.Parse("/jwks.json" + issuer)
	configUri, _ := sa.BaseUrl.Parse("/stream")
	statusUri, _ := sa.BaseUrl.Parse("/status")
	addSubUri, _ := sa.BaseUrl.Parse("/add-subject")
	remSubUri, _ := sa.BaseUrl.Parse("/remove-subject")
	verifyUri, _ := sa.BaseUrl.Parse("/verification")
	config := model.TransmitterConfiguration{
		Issuer:  issuer,
		JwksUri: jwksUri.String(),
		DeliveryMethodsSupported: []string{
			model.DeliveryPoll,
			model.DeliveryPush,
		},
		ConfigurationEndpoint:  configUri.String(),
		StatusEndpoint:         statusUri.String(),
		AddSubjectEndpoint:     addSubUri.String(),
		RemoveSubjectEndpoint:  remSubUri.String(),
		VerificationEndpoint:   verifyUri.String(),
		CriticalSubjectMembers: nil,
	}
	resp, _ := json.Marshal(config)
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write(resp)
}
